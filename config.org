#+title: My Literate Doom Emacs Configuration
#+property: header-args :noweb yes
#+startup: overview
This my "literate" Doom Emacs configuration using org mode and babel tangle.
* Bootstraps :enabled:
Placeholder file templates for default Doom configuration files: =init.el= =config.el= =packages.el=.
#+name: init.el
#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  DO NOT EDIT DIRECTLY, THIS FILE IS AUTO-GENERATED WITH ORG-BABEL-TANGLE!  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(doom! :input
       <<input>>
       :completion
       <<completion>>
       :ui
       <<ui>>
       :editor
       <<editor>>
       :emacs
       <<emacs>>
       :term
       <<term>>
       :checkers
       <<checkers>>
       :tools
       <<tools>>
       :os
       <<os>>
       :lang
       <<lang>>
       :email
       <<email>>
       :app
       <<app>>
       :config
       <<config>>
)
#+end_src
#+name: config.el
#+begin_src emacs-lisp :tangle config.el
;;; config.el -*- lexical-binding: t; -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  DO NOT EDIT DIRECTLY, THIS FILE IS AUTO-GENERATED WITH ORG-BABEL-TANGLE!  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src
#+name: packages.el
#+begin_src emacs-lisp :tangle packages.el
;; no-byte-compile: t; -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  DO NOT EDIT DIRECTLY, THIS FILE IS AUTO-GENERATED WITH ORG-BABEL-TANGLE!  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src
* Init (Variables)
Doom modules to enable are defined below.
** Input
Enabled Chinese optimisations.
#+name: input
#+begin_src emacs-lisp
chinese
#+end_src
** Completion
Enable =corfu= and =vertico= for completion.
#+name: completion
#+begin_src emacs-lisp
(corfu +icons +orderless)
(vertico +icons)
#+end_src
** UI
UI plugins/packages to use
#+name: ui
#+begin_src emacs-lisp
doom
doom-dashboard
doom-quit
(emoji +unicode)
hl-todo
hydra
indent-guides
ligatures
modeline
nav-flash
ophints
popup
(treemacs +lsp)
unicode
(vc-gutter +pretty)
vi-tilde-fringe
window-select
workspaces
zen
#+end_src

** Editor
Editor packages to enable.
#+name: editor
#+begin_src emacs-lisp
(evil +everywhere)
file-templates    
fold              
(format +onsave +lsp)
parinfer          
rotate-text
snippets          
word-wrap         
#+end_src

** Emacs
Emacs enhancements
#+name: emacs
#+begin_src emacs-lisp
(dired +icon +dirvish)
electric
(ibuffer +icons)
tramp
undo
vc
#+end_src
** Term
Terminals to enable.
#+name: term
#+begin_src emacs-lisp
vterm
#+end_src

** Checkers
Spell/syntax/grammar checkers.
#+name: checkers
#+begin_src emacs-lisp
(syntax +flymake +icons)
(spell +aspell)
#+end_src

** Tools
Tools...
#+name: tools
#+begin_src emacs-lisp
(eval +overlay)
(lookup +dictionary)
(lsp +peek)
magit
make
pdf
rgb
tree-sitter
#+end_src

** OS
OS settings.
#+name: os
#+begin_src emacs-lisp
(:if (featurep :system 'macos) macos)
tty
#+end_src

** Lang
Programming languages.
#+name: lang
#+begin_src emacs-lisp
emacs-lisp
(nix +lsp +tree-sitter)
(json +lsp)
(javascript +lsp +tree-sitter)
(latex +cdlatex +lsp)
(lua +lsp +tree-sitter +fennel) 
(markdown +grip +tree-sitter)
(org +dragndrap +hugo +pandoc +pomodoro +present +roam)
(python +lsp +tree-sitter)
(rust +lsp +tree-sitter)
(sh +lsp)
(web +lsp +tree-sitter)
(yaml +lsp +tree-sitter)
#+end_src
** Email
Email in Emacs...
#+name: email
#+begin_src emacs-lisp
(mu4e +org)
#+end_src
** App
Applications...?
#+name: app
#+begin_src emacs-lisp
calendar
everywhere
#+end_src

** Config
#+name: config
#+begin_src emacs-lisp
(default +bindings +smartparens)
#+end_src
* Core
These are core Emacs/Doom settings.
** Variables
*** User Information
#+name: user-name
#+begin_src emacs-lisp
"Yu Li (James)"
#+end_src
#+name: user-email
#+begin_src emacs-lisp
"jamesyuli@outlook.com"
#+end_src
*** Font
#+name: default-font
#+begin_src emacs-lisp
"Maple Mono NF CN"
#+end_src
#+name: variable-font
#+begin_src emacs-lisp
"Noto Sans CJK SC"
#+end_src
#+name: serif-font
#+begin_src emacs-lisp
"Noto Serif CJK SC"
#+end_src
#+name: symbol-font
#+begin_src emacs-lisp
"Symbols Nerd Font Mono"
#+end_src
#+name: unicode-font
#+begin_src emacs-lisp
"Symbols Nerd Font Mono"
#+end_src
*** Themes :enabled:
#+begin_src emacs-lisp :tangle packages.el
(package! standard-themes)
(package! ef-themes)
#+end_src

#+name: theme
#+begin_src emacs-lisp
'ef-dream
#+end_src
** Code :enabled:
#+begin_src emacs-lisp :tangle config.el 
(setq user-full-name <<user-name>>
      user-mail-address <<user-email>>) 
(setq doom-font (font-spec :family <<default-font>> :size 16 :weight 'Regular)
      doom-variable-pitch-font (font-spec :family <<variable-font>> :size 16)
      doom-serif-font (font-spec :family <<serif-font>> :size 16)
      doom-symbol-font (font-spec :family <<symbol-font>> :size 16)
      doom-unicode-font (font-spec :family <<unicode-font>> :size 16))
(setq doom-theme <<theme>>)
#+end_src
* Quality of Life :enabled:
:PROPERTIES:
:header-args: :tangle config.el
:END:
** Which-key Buffer
Map =Ctrl n/p= to cyble =which-key= buffer pages. 
#+begin_src emacs-lisp
(map! :map which-key-mode-map "C-n" #'which-key-show-next-page-no-cycle)
(map! :map which-key-mode-map "C-p" #'which-key-show-previous-page-no-cycle)
#+end_src
** Snipping
Make =s= to use =avy= instead, mimicing =flash.nvim=.
#+begin_src emacs-lisp
(after! evil-snipe
  (setq evil-snipe-scope 'visible
        evil-snipe-smart-case 1)
  (evil-define-key '(normal motion) evil-snipe-local-mode-map
    "s" 'evil-avy-goto-char-timer))
#+end_src
* Org Mode
Make sure to =enable= "Extras" packages/modules with *:enabled:* tag.
** Variables
Org mode notes directory.
#+name: org-dir
#+begin_src emacs-lisp
~/denote
#+end_src
** Core :enabled:
:PROPERTIES:
:header-args: :tangle config.el 
:END:
Core/basic org mode configurations.
*** Directory
#+begin_src emacs-lisp
(setq org-directory "<<org-dir>>"
      org-agenda-files '("<<org-dir>>"))
#+end_src
*** Babel Languages
#+begin_src emacs-lisp
(after! org
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (elisp . t)
     (emacs-lisp . t)
     (lua . t)
     (makefile . t)
     (js . t)
     (css . t)
     (shell . t)
     (python . t)
     (rust . t))))
#+end_src
** Extras
Make sure to *enable* each module by add the :enabled: tag.
*** Auto Tangle :enabled:
Auto tangle files upon save, using the =#+auto_tangle: t= file property.
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! org-autolist)
#+end_src
**** Config
#+begin_src emacs-lisp :tangle config.el
(add-hook! org-mode-hook #'org-auto-tangle-mode)
;; Files to blacklist
(setq org-auto-tangle-babel-safelist '(
                                       "~/example.org"
                                       "~/example2.org"))
#+end_src
*** View Mode :enabled:
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! org-view-mode)
#+end_src
**** Config
#+begin_src emacs-lisp :tangle config.el
(use-package org-view-mode
  :ensure t)
#+end_src
**** Key Bind
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix "t"
       :desc "Org View Mode" "V" #'org-view-mode))
#+end_src
*** Denote :enabled:
**** Core
Core Denote and Denote-org configuration.
***** Package
#+begin_src emacs-lisp :tangle packages.el
(package! denote)
(package! denote-org)
#+end_src
***** Config
#+begin_src emacs-lisp :tangle config.el 
(use-package! denote
  :hook
  (dired-mode . denote-dired-mode)
  :config
  (setq denote-directory "<<org-dir>>")
  (setq denote-file-type 'org)
  
  ;; Rename Denote buffers
  (denote-rename-buffer-mode 1)
  (setq denote-buffer-name-prefix "<NOTE> ")
  (setq denote-rename-buffer-format "[%k] %t")
  
  ;; Known keywords
  (setq denote-known-keywords nil)
  (setq denote-date-prompt-use-org-read-date t))
#+end_src
***** Key Binds
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("d" . "denote")
       :desc "new note" "n" #'denote
       :desc "new note + date" "N" #'denote-date
       ;; :desc "new note in subdir" "s" #'denote-subdirectory
       :desc "list all notes" "D" #'denote-menu-list-notes
       :desc "open/create note" "d" #'denote-open-or-create
       :desc "find link" "l" #'denote-find-link
       :desc "backlinks" "b" #'denote-backlinks
       :desc "backlinks for heading" "B" #'denote-org-backlinks-for-heading
       :desc "template" "t" #'denote-template
       :desc "capture region" "c" #'denote-region
       :desc "heading as note" "h" #'denote-org-extract-org-subtree
       (:prefix ("i" . "insert")
        :desc "insert/create link" "l" #'denote-link-or-create
        :desc "insert/create link in bg" "L" #'denote-link-after-creating
        :desc "insert front matter" "f" #'denote-add-front-matter
        :desc "insert heading link" "h" #'denote-org-link-to-heading
        :desc "insert link matching REGEXP" "r" #'denote-add-links
        (:prefix ("d" . "dynamic blocks")
         :desc "links" "l" #'denote-org-dblock-insert-links
         :desc "backlinks" "b" #'denote-org-dblock-insert-backlinks
         :desc "files" "f" #'denote-org-dblock-insert-files
         :desc "files (headings)" "f" #'denote-org-dblock-insert-files-as-headings
         :desc "missing links" "m" #'denote-org-dblock-insert-missing-links))
       (:prefix ("r" . "rename")
        :desc "rename note" "r" #'denote-rename-file
        :desc "rename keyword" "k" #'denote-rename-file-keywords
        :desc "rename signature" "s" #'denote-rename-file-signature
        :desc "rename front matter" "f" #'denote-rename-file-using-front-matter
        :desc "rename title" "t" #'denote-rename-file-title)))
#+end_src
**** Consult
***** Package
#+begin_src emacs-lisp :tangle packages.el
(package! consult-denote)
#+end_src
***** Config
#+begin_src emacs-lisp :tangle config.el
(use-package! consult-denote
  :config
  (consult-denote-mode 1))
#+end_src
***** Key Binds
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("d" . "denote")
       :desc "Search notes" "s" #'consult-denote-find
       :desc "Search notes w/grep" "S" #'consult-denote-grep))
#+end_src

**** Journal
***** Package
#+begin_src emacs-lisp :tangle packages.el
(package! denote-journal)
#+end_src
***** Config
#+begin_src emacs-lisp :tangle config.el
(use-package! denote-journal
  :after denote
  :config
  (setq denote-journal-title-format "%Y-%m-%d"))
#+end_src
***** Key Binds
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("d" . "denote")
       :desc "find/create journal" "j" #'denote-journal-new-or-existing-entry
       :desc "find/create journal w/date" "J" #'(lambda ()
                                                  (interactive)
                                                  (let ((current-prefix-arg '(4)))
                                                    (call-interactively #'denote-journal-new-or-existing-entry)))
       (:prefix ("i" . "insert")
        :desc "insert journal link" "j" #'denote-journal-link-or-create-entry
        :desc "insert journal link w/date" "J" #'(lambda ()
                                                   (interactive)
                                                   (let ((current-prefix-arg '(4)))
                                                     (call-interactively #'denote-journal-link-or-create-entry))))))
#+end_src

**** Explore
***** Package
#+begin_src emacs-lisp :tangle packages.el
(package! denote-explore)
#+end_src
***** Config
#+begin_src emacs-lisp :tangle config.el
(use-package! denote-explore
  :after denote
  :config
  (require 'denote))
#+end_src
***** Key Binds
#+begin_src emacs-lisp :tangle config.el
(after! denote-explore
  (map! :leader
        (:prefix ("d" . "denote")
                 (:prefix ("e" . "explore")
                  :desc "network" "n" #'denote-explore-network
                  :desc "network regenerate" "N" #'denote-explore-network-regenerate

                  (:prefix ("c" . "count")
                   :desc "notes" "n" #'denote-explore-count-notes
                   :desc "keywords" "k" #'denote-explore-count-keywords)

                  (:prefix ("b" . "bar chart")
                   :desc "file types" "f" #'denote-explore-barchart-filetypes
                   :desc "keywords" "k" #'denote-explore-barchart-keywords
                   :desc "timeline" "t" #'denote-explore-barchart-timeline
                   :desc "degree" "d" #'denote-explore-barchart-degree
                   :desc "backlinks" "b" #'denote-explore-barchart-backlinks)

                  (:prefix ("r" . "random walks")
                   :desc "note" "n" #'denote-explore-random-note
                   :desc "regex" "r" #'denote-explore-random-regex
                   :desc "link" "l" #'denote-explore-random-link
                   :desc "keyword" "k" #'denote-explore-random-keyword)

                  (:prefix ("j" . "janitor")
                   :desc "duplicate notes" "d" #'denote-explore-duplicate-notes
                   :desc "duplicate notes(dired)" "D" #'denote-explore-duplicate-notes-dired
                   :desc "missing links" "l" #'denote-explore-missing-links
                   :desc "zero keywords" "z" #'denote-explore-zero-keywords
                   :desc "single keywords" "k" #'denote-explore-single-keywords
                   :desc "rename keywords" "r" #'denote-explore-rename-keywords
                   :desc "sync metadata" "s" #'denote-explore-sync-metadata
                   :desc "isolated files" "i" #'denote-explore-isolated-files)))))
#+end_src
***** Temporary Solution
Temporary solution for "denote-id-regexp" being obsolete in the new version of Denote.
#+begin_src emacs-lisp :tangle no
(after! denote
  (unless (boundp 'denote-id-regexp)
    ;; Try to find the actual variable name in your denote version
    (setq denote-id-regexp
          (or (and (boundp 'denote-identifier-regexp) denote-identifier-regexp)
              "[0-9]\\{8\\}T[0-9]\\{6\\}"))))  ; fallback pattern
#+end_src

**** Completion Formatting
Custom functions to make the formatting of calling =denote-open-or-create= to be cleaner.
It would show up something like this instead:
|-----------------------------------------------------------------------------|
| Find file: note t_                                                          |
|-----------------------------------------------------------------------------|
| [ 2003-09-01 ] note title                                 keyword1 keyword2 |
|                                                                             |
|-----------------------------------------------------------------------------|
#+begin_src emacs-lisp :tangle config.el
;; Simple denote completion formatting
(defun my-format-denote-candidate (file)
  "Format denote file for completion display with right-aligned keywords."
  (when (string-match-p "[0-9]\\{8\\}T[0-9]\\{6\\}" file)
    (let* ((full-path (expand-file-name file (denote-directory)))
           (date-str (ignore-errors (denote-retrieve-filename-identifier full-path)))
           (title (ignore-errors (denote-retrieve-filename-title full-path)))
           (keywords (ignore-errors (denote-retrieve-filename-keywords full-path))))
      (when date-str
        (let* ((formatted-date (format "[ %s-%s-%s ]"
                                       (substring date-str 0 4)
                                       (substring date-str 4 6)
                                       (substring date-str 6 8)))
               (formatted-title (if title
                                    (replace-regexp-in-string "-" " " title)
                                  ""))
               (formatted-keywords (cond
                                    ((listp keywords)
                                     (mapconcat (lambda (k) (replace-regexp-in-string "_" " " k)) keywords " "))
                                    ((stringp keywords)
                                     (replace-regexp-in-string "_" " " keywords))
                                    (t "")))
               ;; Calculate padding to right-align keywords dynamically
               (left-part (format "%s %s" formatted-date formatted-title))
               (window-width (window-width (minibuffer-window)))
               (padding-needed (max 1 (- window-width (length left-part) (length formatted-keywords) 2)))
               (padding (make-string padding-needed ?\s)))

          (if (and formatted-keywords (not (string-empty-p formatted-keywords)))
              (format "%s%s%s" left-part padding formatted-keywords)
            left-part))))))

;; Override the denote file prompt function
(defun my-denote-file-prompt (&optional files-matching-regexp prompt-text no-require-match &rest _ignore)
  "Custom denote file prompt with formatted display."
  (let* ((files (denote-directory-files files-matching-regexp))
         (file-alist (mapcar (lambda (file)
                               (let* ((relative-file (denote-get-file-name-relative-to-denote-directory file))
                                      (formatted (my-format-denote-candidate relative-file)))
                                 (cons (or formatted relative-file) file)))
                             files))
         (choice (completing-read
                  (or prompt-text "Select file: ")
                  file-alist nil
                  (unless no-require-match :require-match))))
    (cdr (assoc choice file-alist))))

;; Apply the override
(advice-add 'denote-file-prompt :override #'my-denote-file-prompt)
#+end_src
**** Git Sync
Automatic git sync for denote notes directory.
***** Configuration
#+begin_src emacs-lisp :tangle config.el
(require 'vc-git)
(require 'filenotify)

(defgroup denote-git-sync nil
  "Git synchronization for Denote."
  :group 'denote)

(defcustom denote-git-sync-interval (* 15 60)
  "Interval in seconds for periodic sync (default: 15 minutes)."
  :type 'integer
  :group 'denote-git-sync)

(defcustom denote-git-sync-verbose t
  "If non-nil, show messages for successful syncs. Errors are always shown."
  :type 'boolean
  :group 'denote-git-sync)

(defvar denote-git-sync-process nil
  "The current git sync process, if any.")

(defvar denote-git-sync-timer nil
  "The periodic sync timer.")

(defvar denote-git-sync-debounce-timer nil
  "Timer to debounce rapid file events.")

(defvar denote-git-sync-watcher-descriptor nil
  "The file notification watcher descriptor.")
#+end_src

***** Logging & Helpers
#+begin_src emacs-lisp :tangle config.el
(defun denote-git-sync-log (msg &optional level)
  "Log MSG with LEVEL (:info, :success, :error)."
  (let ((formatted-msg (format "[Denote-Sync] %s" msg)))
    (cond
     ((eq level :error)
      (message "%s" (propertize formatted-msg 'face 'error)))
     ((eq level :success)
      (when denote-git-sync-verbose
        (message "%s" (propertize formatted-msg 'face 'success))))
     (t
      (when denote-git-sync-verbose
        (message "%s" formatted-msg))))))

(defun denote-git-sync-in-repo-p ()
  "Check if `denote-directory` is a git repository."
  (when (and (stringp denote-directory) (file-directory-p denote-directory))
    (let ((default-directory denote-directory))
      (zerop (call-process "git" nil nil nil "rev-parse" "--is-inside-work-tree")))))

(defun denote-git-sync-get-branch ()
  "Get the current git branch name."
  (when (and (stringp denote-directory) (file-directory-p denote-directory))
    (let ((default-directory denote-directory))
      (string-trim (shell-command-to-string "git rev-parse --abbrev-ref HEAD")))))

(defun denote-git-sync-has-changes-p ()
  "Check if there are local changes or unpushed commits."
  (when (and (stringp denote-directory) (file-directory-p denote-directory))
    (let ((default-directory denote-directory))
      (or (not (string-empty-p (shell-command-to-string "git status --porcelain")))
          (not (string-empty-p (shell-command-to-string "git log @{u}..HEAD 2>/dev/null")))))))
#+end_src

***** Async Process Management
#+begin_src emacs-lisp :tangle config.el
(defun denote-git-sync-run-git (args callback)
  "Run git with ARGS asynchronously. Call CALLBACK on success."
  (when (process-live-p denote-git-sync-process)
    (kill-process denote-git-sync-process))
  
  (let ((default-directory denote-directory)
        (out-buffer (get-buffer-create " *denote-git-sync-output*")))
    (with-current-buffer out-buffer (erase-buffer))
    (denote-git-sync-log (format "Running: git %s" (mapconcat 'identity args " ")))
    
    (setq denote-git-sync-process
          (make-process
           :name "denote-git-sync"
           :buffer out-buffer
           :command (cons "git" args)
           :sentinel (lambda (proc event)
                       (when (memq (process-status proc) '(exit signal))
                         (if (zerop (process-exit-status proc))
                             (funcall callback)
                           (denote-git-sync-log (format "Git command failed: %s" (string-trim event)) :error))
                         (setq denote-git-sync-process nil)))))))
#+end_src

***** Sync Logic Steps
#+begin_src emacs-lisp :tangle config.el
(defun denote-git-sync-step-push ()
  "Step 4: Push changes."
  (let ((branch (denote-git-sync-get-branch)))
    (if branch
        (denote-git-sync-run-git 
         (list "push" "origin" branch)
         (lambda () (denote-git-sync-log "Sync complete!" :success)))
      (denote-git-sync-log "Could not determine branch." :error))))

(defun denote-git-sync-step-pull ()
  "Step 3: Pull (rebase) remote changes."
  (let ((branch (denote-git-sync-get-branch)))
    (if branch
        (denote-git-sync-run-git 
         (list "pull" "--rebase" "origin" branch)
         #'denote-git-sync-step-push)
      (denote-git-sync-log "Could not determine branch." :error))))

(defun denote-git-sync-step-commit ()
  "Step 2: Commit changes."
  (let ((msg (format "Auto-sync: %s" (format-time-string "%Y-%m-%d %H:%M:%S"))))
    (denote-git-sync-run-git 
     (list "commit" "-m" msg)
     #'denote-git-sync-step-pull)))

(defun denote-git-sync-step-add ()
  "Step 1: Add all changes."
  (denote-git-sync-run-git 
   (list "add" "-A")
   #'denote-git-sync-step-commit))
#+end_src

***** Main Commands & Watcher
#+begin_src emacs-lisp :tangle config.el
(defun denote-git-sync ()
  "Synchronize `denote-directory` with git remote.
Flow: Add -> Commit -> Pull (Rebase) -> Push."
  (interactive)
  (if (not (denote-git-sync-in-repo-p))
      (denote-git-sync-log "Not a git repository." :error)
    (if (denote-git-sync-has-changes-p)
        (denote-git-sync-step-add)
      (denote-git-sync-log "No changes to sync." :info))))

(defun denote-git-sync-trigger (&optional _event)
  "Trigger sync with debounce. Ignores _EVENT argument from file watcher."
  (when (timerp denote-git-sync-debounce-timer)
    (cancel-timer denote-git-sync-debounce-timer))
  (setq denote-git-sync-debounce-timer
        (run-with-timer 2 nil (lambda ()
                                (denote-git-sync-log "Auto-sync triggered by file change..." :info)
                                (denote-git-sync)))))

(defun denote-git-sync-enable-watcher ()
  "Enable file system watcher for denote directory."
  (interactive)
  (when denote-git-sync-watcher-descriptor
    (file-notify-rm-watch denote-git-sync-watcher-descriptor))
  
  (if (and (stringp denote-directory) (file-directory-p denote-directory))
      (progn
        (setq denote-git-sync-watcher-descriptor
              (file-notify-add-watch denote-directory
                                     '(change) ;; covers create, delete, modify, rename
                                     #'denote-git-sync-trigger))
        (message "Denote Git Sync watcher enabled on %s" denote-directory))
    (message "Cannot enable watcher: denote-directory is invalid.")))

(defun denote-git-sync-disable-watcher ()
  "Disable file system watcher."
  (interactive)
  (when denote-git-sync-watcher-descriptor
    (file-notify-rm-watch denote-git-sync-watcher-descriptor)
    (setq denote-git-sync-watcher-descriptor nil))
  (message "Denote Git Sync watcher disabled."))

;; Initialize Logic
(after! denote
  ;; Enable watcher
  (denote-git-sync-enable-watcher)
  
  ;; Fallback: Enable periodic sync
  (when denote-git-sync-timer (cancel-timer denote-git-sync-timer))
  (setq denote-git-sync-timer
        (run-at-time nil denote-git-sync-interval #'denote-git-sync)))
#+end_src

***** Key Binds
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("d" . "denote")
                   (:prefix ("g" . "git")
                    :desc "Sync notes" "s" #'denote-git-sync)))
#+end_src
* Pulsar :enabled:
Never loose your cursor again.
** Package
#+begin_src emacs-lisp :tangle packages.el
(package! pulsar)
#+end_src
** Config
#+begin_src emacs-lisp :tangle config.el
(use-package! pulsar
  :init
  (pulsar-global-mode 1)
  :config
  (setq pulsar-delay 0.1
        pulsar-iterations 20
        pulsar-face 'pulsar-yellow
        pulsar-region-face 'pulsar-cyan
        pulsar-highlight-face 'pulsar-magenta)
  :hook
  ((next-error-hook . pulsar-pulse-line)
   (minibuffer-setup-hook . pulsar-pulse-line-blue)
   (consult-after-jump-hook . pulsar-recenter-top)
   (consult-after-jump-hook . pulsar-reveal-entry)))
#+end_src
* Ultra Scroll :enabled:
Ultra smooth scrolling.
** Package
#+begin_src emacs-lisp :tangle packages.el
(package! ultra-scroll)
#+end_src
** Config
#+begin_src emacs-lisp :tangle config.el
(use-package! ultra-scroll
  :init
  (setq scroll-conservatively 3
        scroll-margin 0)
  :config
  (ultra-scroll-mode 1))
#+end_src

* KDL Mode :enabled:
=.kdl= file support for Niri WM config.
** Package
#+begin_src emacs-lisp :tangle packages.el
(package! kdl-mode)
#+end_src
** Config
#+begin_src emacs-lisp :tangle config.el
(use-package! kdl-mode
  :mode "\\.kdl\\'"
  :config
  (setq kdl-selection-method 'tree-sitter))
#+end_src
* Spelling :enabled:
** Config
#+begin_src emacs-lisp :tangle config.el
(after! ispell
  (setq ispell-program-name "aspell"
        ispell-aspell-dict-dir (executable-find "aspell")
        ispell-dictionary "en_GB"
        ispell-extra-args '("--encoding=utf-8"))
  (setq ispell-personal-dictionary (expand-file-name "doom/ispell/en.pws" "~")))
#+end_src
* Spacious Padding :enabled:
** Package
#+begin_src emacs-lisp :tangle packages.el
(package! spacious-padding)
#+end_src
** Config
#+begin_src emacs-lisp :tangle config.el
(setq spacious-padding-widths
      '( :internal-border-width 15
         :header-line-width 4
         :mode-line-width 6
         :tab-width 4
         :right-divider-width 30
         :scroll-bar-width 8))

(spacious-padding-mode 1)
#+end_src
* Email :enabled:
** Config
#+begin_src emacs-lisp :tangle config.el
(after! mu4e
  (setq mu4e-mu-binary (executable-find "mu"))
  (setq mu4e-update-interval 300)
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-contexts
        (list
         (make-mu4e-context
          :name "Mailbox"
          :enter-func (lambda () (mu4e-message "Switch to Mailbox"))
          :match-func (lambda (msg)
                        (when msg
                          (string-prefix-p "/Mailbox" (mu4e-message-field msg :maildir))))
          :vars '((user-mail-address . "jamesyuli@mailbox.org")
                  (user-full-name . "Yu Li")
                  (mu4e-drafts-folder . "/Mailbox/Drafts")
                  (mu4e-sent-folder . "/Mailbox/Sent")
                  (mu4e-refile-folder . "/Mailbox/Archive")
                  (mu4e-trash-folder . "/Mailbox/Trash")))))
  (setq mu4e-context-policy 'pick-first))
#+end_src
** Un-pin =org-msg= for NixOS
#+begin_src emacs-lisp :tangle packages.el
(package! org-msg :pin nil)
#+end_src
